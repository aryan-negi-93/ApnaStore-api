{"version":3,"sources":["../src/del.ts","../src/head.ts","../src/list.ts","../src/copy.ts","../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\n/**\n * Deletes one or multiple blobs from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#delete-a-blob\n *\n * @param url - Blob url or array of blob urls that identify the blobs to be deleted. You can only delete blobs that are located in a store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param options - Additional options for the request.\n */\nexport async function del(\n  url: string[] | string,\n  options?: BlobCommandOptions,\n): Promise<void> {\n  await requestApi(\n    '/delete',\n    {\n      method: 'POST',\n      headers: { 'content-type': 'application/json' },\n      body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n    },\n    options,\n  );\n}\n","import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\nexport interface HeadBlobResult {\n  url: string;\n  downloadUrl: string;\n  size: number;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n  cacheControl: string;\n}\n\ninterface HeadBlobApiResponse extends Omit<HeadBlobResult, 'uploadedAt'> {\n  uploadedAt: string; // when receiving data from our API, uploadedAt is a string\n}\n\n/**\n * Fetches metadata of a blob object.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#get-blob-metadata\n *\n * @param url - Blob url to lookup.\n * @param options - Additional options for the request.\n */\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions,\n): Promise<HeadBlobResult> {\n  const searchParams = new URLSearchParams({ url });\n\n  const response = await requestApi<HeadBlobApiResponse>(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    { method: 'GET' },\n    options,\n  );\n\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt),\n  };\n}\n","import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\nexport interface ListBlobResultBlob {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  size: number;\n  uploadedAt: Date;\n}\n\nexport interface ListBlobResult {\n  blobs: ListBlobResultBlob[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\nexport interface ListFoldedBlobResult extends ListBlobResult {\n  folders: string[];\n}\n\ninterface ListBlobApiResponseBlob\n  extends Omit<ListBlobResultBlob, 'uploadedAt'> {\n  uploadedAt: string;\n}\n\ninterface ListBlobApiResponse extends Omit<ListBlobResult, 'blobs'> {\n  blobs: ListBlobApiResponseBlob[];\n  folders?: string[];\n}\n\nexport interface ListCommandOptions<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> extends BlobCommandOptions {\n  /**\n   * The maximum number of blobs to return.\n   * @defaultvalue 1000\n   */\n  limit?: number;\n  /**\n   * Filters the result to only include blobs that start with this prefix.\n   * If used together with `mode: 'folded'`, make sure to include a trailing slash after the foldername.\n   */\n  prefix?: string;\n  /**\n   * The cursor to use for pagination. Can be obtained from the response of a previous `list` request.\n   */\n  cursor?: string;\n  /**\n   * Defines how the blobs are listed\n   * - `expanded` the blobs property contains all blobs.\n   * - `folded` the blobs property contains only the blobs at the root level of your store. Blobs that are located inside a folder get merged into a single entry in the folder response property.\n   * @defaultvalue 'expanded'\n   */\n  mode?: M;\n}\n\ntype ListCommandResult<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> = M extends 'folded' ? ListFoldedBlobResult : ListBlobResult;\n\n/**\n * Fetches a paginated list of blob objects from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#list-blobs\n *\n * @param options - Additional options for the request.\n */\nexport async function list<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n>(options?: ListCommandOptions<M>): Promise<ListCommandResult<M>> {\n  const searchParams = new URLSearchParams();\n\n  if (options?.limit) {\n    searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    searchParams.set('cursor', options.cursor);\n  }\n  if (options?.mode) {\n    searchParams.set('mode', options.mode);\n  }\n\n  const response = await requestApi<ListBlobApiResponse>(\n    `?${searchParams.toString()}`,\n    { method: 'GET' },\n    options,\n  );\n\n  if (options?.mode === 'folded') {\n    return {\n      folders: response.folders ?? [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult),\n    } as ListCommandResult<M>;\n  }\n\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult),\n  } as ListCommandResult<M>;\n}\n\nfunction mapBlobResult(\n  blobResult: ListBlobApiResponseBlob,\n): ListBlobResultBlob {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n","import { requestApi } from './api';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError } from './helpers';\n\nexport type CopyCommandOptions = CommonCreateBlobOptions;\n\nexport interface CopyBlobResult {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  contentType?: string;\n  contentDisposition: string;\n}\n\n/**\n * Copies a blob to another location in your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#copy-a-blob\n *\n * @param fromUrl - The blob URL to copy. You can only copy blobs that are in the store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param toPathname - The pathname to copy the blob to. This includes the filename.\n * @param options - Additional options. The copy method will not preserve any metadata configuration (e.g.: 'cacheControlMaxAge') of the source blob. If you want to copy the metadata, you need to define it here again.\n */\nexport async function copy(\n  fromUrl: string,\n  toPathname: string,\n  options: CopyCommandOptions,\n): Promise<CopyBlobResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  const headers: Record<string, string> = {};\n\n  if (options.addRandomSuffix !== undefined) {\n    headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n  }\n\n  if (options.contentType) {\n    headers['x-content-type'] = options.contentType;\n  }\n\n  if (options.cacheControlMaxAge !== undefined) {\n    headers['x-cache-control-max-age'] = options.cacheControlMaxAge.toString();\n  }\n\n  const response = await requestApi<CopyBlobResult>(\n    `/${toPathname}?fromUrl=${fromUrl}`,\n    { method: 'PUT', headers },\n    options,\n  );\n\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n  };\n}\n","import type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\nimport { createCreateMultipartUploadMethod } from './multipart/create';\nimport type { UploadPartCommandOptions } from './multipart/upload';\nimport { createUploadPartMethod } from './multipart/upload';\nimport type { CompleteMultipartUploadCommandOptions } from './multipart/complete';\nimport { createCompleteMultipartUploadMethod } from './multipart/complete';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { createCreateMultipartUploaderMethod } from './multipart/create-uploader';\n\n// expose generic BlobError and download url util\nexport { BlobError, getDownloadUrl } from './helpers';\n\n// expose api BlobErrors\nexport {\n  BlobAccessError,\n  BlobNotFoundError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n  BlobServiceNotAvailable,\n} from './api';\n\n// vercelBlob.put()\n\nexport type { PutBlobResult } from './put-helpers';\nexport type { PutCommandOptions };\n\n/**\n * Uploads a blob into your store from your server.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob\n *\n * If you want to upload from the browser directly, check out the documentation for client uploads: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads\n *\n * @param pathname - The pathname to upload the blob to. For file upload this includes the filename. Pathnames that end with a slash are treated as folder creations.\n * @param bodyOrOptions - Either the contents of your blob or the options object. For file uploads this has to be a supported fetch body type https://developer.mozilla.org/en-US/docs/Web/API/fetch#body. For folder creations this is the options object since no body is required.\n * @param options - Additional options like `token` or `contentType` for file uploads. For folder creations this argument can be ommited.\n */\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\n//  vercelBlob.del()\n\nexport { del } from './del';\n\n// vercelBlob.head()\n\nexport type { HeadBlobResult } from './head';\nexport { head } from './head';\n\n// vercelBlob.list()\n\nexport type {\n  ListBlobResultBlob,\n  ListBlobResult,\n  ListCommandOptions,\n  ListFoldedBlobResult,\n} from './list';\nexport { list } from './list';\n\n// vercelBlob.copy()\n\nexport type { CopyBlobResult, CopyCommandOptions } from './copy';\nexport { copy } from './copy';\n\n// vercelBlob. createMultipartUpload()\n// vercelBlob. uploadPart()\n// vercelBlob. completeMultipartUpload()\n// vercelBlob. createMultipartUploaded()\n\nexport const createMultipartUpload =\n  createCreateMultipartUploadMethod<CommonCreateBlobOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport const createMultipartUploader =\n  createCreateMultipartUploaderMethod<CommonCreateBlobOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport type { UploadPartCommandOptions };\nexport const uploadPart = createUploadPartMethod<UploadPartCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\nexport type { CompleteMultipartUploadCommandOptions };\nexport const completeMultipartUpload =\n  createCompleteMultipartUploadMethod<CompleteMultipartUploadCommandOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport type { Part, PartInput } from './multipart/helpers';\n"]}