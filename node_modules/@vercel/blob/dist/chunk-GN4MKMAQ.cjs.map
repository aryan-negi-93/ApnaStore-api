{"version":3,"sources":["../src/helpers.ts","../src/api.ts","../src/debug.ts","../src/put-helpers.ts","../src/multipart/complete.ts","../src/multipart/create.ts","../src/multipart/upload.ts","../src/multipart/helpers.ts","../src/multipart/uncontrolled.ts","../src/put.ts","../src/multipart/create-uploader.ts"],"names":["_a","_b"],"mappings":"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","sourcesContent":["// common util interface for blob raw commands, not meant to be used directly\n// this is why it's not exported from index/client\n\nexport interface BlobCommandOptions {\n  /**\n   * Define your blob API token.\n   * @defaultvalue process.env.BLOB_READ_WRITE_TOKEN\n   */\n  token?: string;\n}\n\n// shared interface for put, copy and multipartUpload\nexport interface CommonCreateBlobOptions extends BlobCommandOptions {\n  /**\n   * Whether the blob should be publicly accessible. Support for private blobs is planned.\n   */\n  access: 'public';\n  /**\n   * Adds a random suffix to the filename.\n   * @defaultvalue true\n   */\n  addRandomSuffix?: boolean;\n  /**\n   * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.\n   */\n  contentType?: string;\n  /**\n   * Number in seconds to configure the edge and browser cache. The maximum values are 5 minutes for the edge cache and unlimited for the browser cache.\n   * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob#caching\n   * @defaultvalue 365 * 24 * 60 * 60 (1 Year)\n   */\n  cacheControlMaxAge?: number;\n}\n\nexport function getTokenFromOptionsOrEnv(options?: BlobCommandOptions): string {\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n\n  throw new BlobError(\n    'No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.',\n  );\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n\nexport function getDownloadUrl(blobUrl: string): string {\n  const url = new URL(blobUrl);\n\n  url.searchParams.set('download', '1');\n\n  return url.toString();\n}\n","import type { RequestInit, Response } from 'undici';\nimport { fetch } from 'undici';\nimport retry from 'async-retry';\nimport { debug } from './debug';\nimport type { BlobCommandOptions } from './helpers';\nimport { BlobError, getTokenFromOptionsOrEnv } from './helpers';\n\nexport class BlobAccessError extends BlobError {\n  constructor() {\n    super('Access denied, please provide a valid token for this resource.');\n  }\n}\n\nexport class BlobStoreNotFoundError extends BlobError {\n  constructor() {\n    super('This store does not exist.');\n  }\n}\n\nexport class BlobStoreSuspendedError extends BlobError {\n  constructor() {\n    super('This store has been suspended.');\n  }\n}\n\nexport class BlobUnknownError extends BlobError {\n  constructor() {\n    super('Unknown error, please visit https://vercel.com/help.');\n  }\n}\n\nexport class BlobNotFoundError extends BlobError {\n  constructor() {\n    super('The requested blob does not exist');\n  }\n}\n\nexport class BlobServiceNotAvailable extends BlobError {\n  constructor() {\n    super('The blob service is currently not available. Please try again.');\n  }\n}\n\nexport class BlobServiceRateLimited extends BlobError {\n  public readonly retryAfter: number;\n\n  constructor(seconds?: number) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${\n        seconds ? ` - try again in ${seconds} seconds` : ''\n      }.`,\n    );\n\n    this.retryAfter = seconds ?? 0;\n  }\n}\n\ntype BlobApiErrorCodes =\n  | 'store_suspended'\n  | 'forbidden'\n  | 'not_found'\n  | 'unknown_error'\n  | 'bad_request'\n  | 'store_not_found'\n  | 'not_allowed'\n  | 'service_unavailable'\n  | 'rate_limited';\n\nexport interface BlobApiError {\n  error?: { code?: BlobApiErrorCodes; message?: string };\n}\n\n// This version is used to ensure that the client and server are compatible\n// The server (Vercel Blob API) uses this information to change its behavior like the\n// response format\nconst BLOB_API_VERSION = 7;\n\nfunction getApiVersion(): string {\n  let versionOverride = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to the BLOB_API_VERSION\n    versionOverride =\n      process.env.VERCEL_BLOB_API_VERSION_OVERRIDE ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n    // noop\n  }\n\n  return `${versionOverride ?? BLOB_API_VERSION}`;\n}\n\nfunction getApiUrl(pathname = ''): string {\n  let baseUrl = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to production endpoint\n    baseUrl =\n      process.env.VERCEL_BLOB_API_URL ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n    // noop\n  }\n  return `${baseUrl || 'https://blob.vercel-storage.com'}${pathname}`;\n}\n\nfunction getRetries(): number {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || '10';\n\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\n\nfunction createBlobServiceRateLimited(\n  response: Response,\n): BlobServiceRateLimited {\n  const retryAfter = response.headers.get('retry-after');\n\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : undefined,\n  );\n}\n\n// reads the body of a error response\nasync function getBlobError(\n  response: Response,\n): Promise<{ code: string; error: BlobError }> {\n  let code: BlobApiErrorCodes;\n  let message: string | undefined;\n\n  try {\n    const data = (await response.json()) as BlobApiError;\n\n    code = data.error?.code ?? 'unknown_error';\n    message = data.error?.message;\n  } catch {\n    code = 'unknown_error';\n  }\n\n  let error: BlobError;\n  switch (code) {\n    case 'store_suspended':\n      error = new BlobStoreSuspendedError();\n      break;\n    case 'forbidden':\n      error = new BlobAccessError();\n      break;\n    case 'not_found':\n      error = new BlobNotFoundError();\n      break;\n    case 'store_not_found':\n      error = new BlobStoreNotFoundError();\n      break;\n    case 'bad_request':\n      error = new BlobError(message ?? 'Bad request');\n      break;\n    case 'service_unavailable':\n      error = new BlobServiceNotAvailable();\n      break;\n    case 'rate_limited':\n      error = createBlobServiceRateLimited(response);\n      break;\n    case 'unknown_error':\n    case 'not_allowed':\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n\n  return { code, error };\n}\n\nexport async function requestApi<TResponse>(\n  pathname: string,\n  init: RequestInit,\n  commandOptions: BlobCommandOptions | undefined,\n): Promise<TResponse> {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n\n  const apiResponse = await retry(\n    async (bail) => {\n      const res = await fetch(getApiUrl(pathname), {\n        ...init,\n        headers: {\n          'x-api-version': apiVersion,\n          authorization: `Bearer ${token}`,\n\n          ...init.headers,\n        },\n      });\n\n      if (res.ok) {\n        return res;\n      }\n\n      const { code, error } = await getBlobError(res);\n\n      // only retry for certain errors\n      if (code === 'unknown_error' || code === 'service_unavailable') {\n        throw error;\n      }\n\n      // don't retry for e.g. suspended stores\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        debug(`retrying API request to ${pathname}`, error.message);\n      },\n    },\n  );\n\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n\n  return (await apiResponse.json()) as TResponse;\n}\n","let debugIsActive = false;\n\n// wrapping this code in a try/catch in case some env doesn't support process.env (vite by default)\ntry {\n  if (\n    process.env.DEBUG?.includes('blob') ||\n    process.env.NEXT_PUBLIC_DEBUG?.includes('blob')\n  ) {\n    debugIsActive = true;\n  }\n} catch (error) {\n  // noop\n}\n\n// Set process.env.DEBUG = 'blob' to enable debug logging\nexport function debug(message: string, ...args: unknown[]): void {\n  if (debugIsActive) {\n    // eslint-disable-next-line no-console -- Ok for debugging\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n","// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport type { Readable } from 'stream';\nimport type { ClientCommonCreateBlobOptions } from './client';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError } from './helpers';\n\nconst putOptionHeaderMap = {\n  cacheControlMaxAge: 'x-cache-control-max-age',\n  addRandomSuffix: 'x-add-random-suffix',\n  contentType: 'x-content-type',\n};\n\nexport interface PutBlobResult {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  contentType?: string;\n  contentDisposition: string;\n}\n\nexport type PutBlobApiResponse = PutBlobResult;\n\nexport type PutBody =\n  | string\n  | Readable // Node.js streams\n  | Buffer // Node.js buffers\n  | Blob\n  | ArrayBuffer\n  | ReadableStream // Streams API (= Web streams in Node.js)\n  | File;\n\nexport type CommonPutCommandOptions = CommonCreateBlobOptions &\n  ClientCommonCreateBlobOptions;\n\nexport interface CreatePutMethodOptions<TOptions> {\n  allowedOptions: (keyof typeof putOptionHeaderMap)[];\n  getToken?: (pathname: string, options: TOptions) => Promise<string>;\n  extraChecks?: (options: TOptions) => void;\n}\n\nexport function createPutHeaders<TOptions extends CommonPutCommandOptions>(\n  allowedOptions: CreatePutMethodOptions<TOptions>['allowedOptions'],\n  options: TOptions,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n\n  if (allowedOptions.includes('contentType') && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n\n  if (\n    allowedOptions.includes('addRandomSuffix') &&\n    options.addRandomSuffix !== undefined\n  ) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix\n      ? '1'\n      : '0';\n  }\n\n  if (\n    allowedOptions.includes('cacheControlMaxAge') &&\n    options.cacheControlMaxAge !== undefined\n  ) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] =\n      options.cacheControlMaxAge.toString();\n  }\n\n  return headers;\n}\n\nexport async function createPutOptions<\n  TOptions extends CommonPutCommandOptions,\n>({\n  pathname,\n  options,\n  extraChecks,\n  getToken,\n}: {\n  pathname: string;\n  options?: TOptions;\n  extraChecks?: CreatePutMethodOptions<TOptions>['extraChecks'];\n  getToken?: CreatePutMethodOptions<TOptions>['getToken'];\n}): Promise<TOptions> {\n  if (!pathname) {\n    throw new BlobError('pathname is required');\n  }\n\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  if (extraChecks) {\n    extraChecks(options);\n  }\n\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n\n  return options;\n}\n","import { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport type { CommonCreateBlobOptions, BlobCommandOptions } from '../helpers';\nimport type {\n  CreatePutMethodOptions,\n  PutBlobApiResponse,\n  PutBlobResult,\n} from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport type { Part } from './helpers';\n\n// shared interface for server and client\nexport interface CommonCompleteMultipartUploadOptions {\n  uploadId: string;\n  key: string;\n}\n\nexport type CompleteMultipartUploadCommandOptions =\n  CommonCompleteMultipartUploadOptions & CommonCreateBlobOptions;\n\nexport function createCompleteMultipartUploadMethod<\n  TOptions extends CompleteMultipartUploadCommandOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, parts: Part[], optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts,\n    });\n  };\n}\n\nexport async function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  parts: Part[];\n  headers: Record<string, string>;\n  options: BlobCommandOptions;\n}): Promise<PutBlobResult> {\n  try {\n    const response = await requestApi<PutBlobApiResponse>(\n      `/mpu/${pathname}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'content-type': 'application/json',\n          'x-mpu-action': 'complete',\n          'x-mpu-upload-id': uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          'x-mpu-key': encodeURI(key),\n        },\n        body: JSON.stringify(parts),\n      },\n      options,\n    );\n\n    debug('mpu: complete', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n","import { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport type { BlobCommandOptions, CommonCreateBlobOptions } from '../helpers';\nimport type { CreatePutMethodOptions } from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\n\nexport function createCreateMultipartUploadMethod<\n  TOptions extends CommonCreateBlobOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options,\n    );\n\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n    };\n  };\n}\n\ninterface CreateMultipartUploadApiResponse {\n  uploadId: string;\n  key: string;\n}\n\nexport async function createMultipartUpload(\n  pathname: string,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<CreateMultipartUploadApiResponse> {\n  debug('mpu: create', 'pathname:', pathname);\n\n  try {\n    const response = await requestApi<CreateMultipartUploadApiResponse>(\n      `/mpu/${pathname}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'x-mpu-action': 'create',\n        },\n      },\n      options,\n    );\n\n    debug('mpu: create', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n","import bytes from 'bytes';\nimport type { BodyInit } from 'undici';\nimport { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport type { CommonCreateBlobOptions, BlobCommandOptions } from '../helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport type { PutBody, CreatePutMethodOptions } from '../put-helpers';\nimport type { Part, PartInput } from './helpers';\n\n// shared interface for server and client\nexport interface CommonMultipartUploadOptions {\n  uploadId: string;\n  key: string;\n  partNumber: number;\n  abortController?: AbortController;\n}\n\nexport type UploadPartCommandOptions = CommonMultipartUploadOptions &\n  CommonCreateBlobOptions;\n\nexport function createUploadPartMethod<\n  TOptions extends UploadPartCommandOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (\n    pathname: string,\n    body: PutBody,\n    optionsInput: TOptions,\n  ): Promise<Part> => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options,\n      abortController: options.abortController,\n    });\n\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber,\n    };\n  };\n}\n\nexport function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  abortController,\n  part,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  headers: Record<string, string>;\n  options: BlobCommandOptions;\n  abortController?: AbortController;\n  part: PartInput;\n}): Promise<UploadPartApiResponse> {\n  return requestApi<UploadPartApiResponse>(\n    `/mpu/${pathname}`,\n    {\n      signal: abortController?.signal,\n      method: 'POST',\n      headers: {\n        ...headers,\n        'x-mpu-action': 'upload',\n        'x-mpu-key': encodeURI(key),\n        'x-mpu-upload-id': uploadId,\n        'x-mpu-part-number': part.partNumber.toString(),\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob as BodyInit,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      duplex: 'half',\n    },\n    options,\n  );\n}\n\n// Most browsers will cap requests at 6 concurrent uploads per domain (Vercel Blob API domain)\n// In other environments, we can afford to be more aggressive\nconst maxConcurrentUploads = typeof window !== 'undefined' ? 6 : 8;\n\n// 5MB is the minimum part size accepted by Vercel Blob, but we set our default part size to 8mb like the aws cli\nconst partSizeInBytes = 8 * 1024 * 1024;\n\nconst maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\n\ninterface UploadPartApiResponse {\n  etag: string;\n}\n\nexport interface BlobUploadPart {\n  partNumber: number;\n  blob: Blob;\n}\n\n// Can we rewrite this function without new Promise?\nexport function uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  stream: ReadableStream<ArrayBuffer>;\n  headers: Record<string, string>;\n  options: BlobCommandOptions;\n}): Promise<Part[]> {\n  debug('mpu: upload init', 'key:', key);\n  const internalAbortController = new AbortController();\n\n  return new Promise((resolve, reject) => {\n    const partsToUpload: BlobUploadPart[] = [];\n    const completedParts: Part[] = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    // this next variable is used to escape the read loop when an error occurs\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n\n    // This must be outside the read loop, in case we reach the maxBytesInMemory and\n    // we exit the loop but some bytes are still to be sent on the next read invocation.\n    let arrayBuffers: ArrayBuffer[] = [];\n    let currentPartBytesRead = 0;\n\n    read().catch(cancel);\n\n    async function read(): Promise<void> {\n      debug(\n        'mpu: upload read start',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = true;\n\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          // eslint-disable-next-line no-await-in-loop -- A for loop is fine here.\n          const { value, done } = await reader.read();\n\n          if (done) {\n            doneReading = true;\n            debug('mpu: upload read consumed the whole stream');\n            // done is sent when the stream is fully consumed. That's why we're not using the value here.\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n\n          currentBytesInMemory += value.byteLength;\n\n          // This code ensures that each part will be exactly of `partSizeInBytes` size\n          // Otherwise R2 will refuse it. AWS S3 is fine with parts of different sizes.\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength,\n            );\n\n            const chunk = value.slice(valueOffset, endOffset);\n\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n\n      debug(\n        'mpu: upload read end',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = false;\n    }\n\n    async function sendPart(part: BlobUploadPart): Promise<void> {\n      activeUploads++;\n\n      debug(\n        'mpu: upload send part start',\n        'partNumber:',\n        part.partNumber,\n        'size:',\n        part.blob.size,\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      try {\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options,\n          abortController: internalAbortController,\n          part,\n        });\n\n        debug(\n          'mpu: upload send part end',\n          'partNumber:',\n          part.partNumber,\n          'activeUploads',\n          activeUploads,\n          'currentBytesInMemory:',\n          `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n          'bytesSent:',\n          bytes(bytesSent),\n        );\n\n        if (rejected) {\n          return;\n        }\n\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag,\n        });\n\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n\n    function sendParts(): void {\n      if (rejected) {\n        return;\n      }\n\n      debug(\n        'send parts',\n        'activeUploads',\n        activeUploads,\n        'partsToUpload',\n        partsToUpload.length,\n      );\n\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n\n    function cancel(error: unknown): void {\n      // a previous call already rejected the whole call, ignore\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (\n        error instanceof TypeError &&\n        (error.message === 'Failed to fetch' ||\n          error.message === 'fetch failed')\n      ) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error as Error);\n      }\n    }\n  });\n}\n","// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport { Readable } from 'stream';\n// eslint-disable-next-line unicorn/prefer-node-protocol -- node:buffer does not resolve correctly in browser and edge\nimport type { Buffer } from 'buffer';\nimport isBuffer from 'is-buffer';\nimport type { PutBody } from '../put-helpers';\n\nexport interface PartInput {\n  partNumber: number;\n  blob: PutBody;\n}\n\nexport interface Part {\n  partNumber: number;\n  etag: string;\n}\n\nexport function toReadableStream(value: PutBody): ReadableStream<ArrayBuffer> {\n  // Already a ReadableStream, nothing to do\n  if (value instanceof ReadableStream) {\n    return value as ReadableStream<ArrayBuffer>;\n  }\n\n  // In the case of a Blob or File (which inherits from Blob), we could use .slice() to create pointers\n  // to the original data instead of loading data in memory gradually.\n  // Here's an explanation on this subject: https://stackoverflow.com/a/24834417\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n\n  if (isNodeJsReadableStream(value)) {\n    return Readable.toWeb(value) as ReadableStream<ArrayBuffer>;\n  }\n\n  let streamValue: Uint8Array | ArrayBuffer;\n\n  if (value instanceof ArrayBuffer) {\n    streamValue = value;\n  } else if (isNodeJsBufferOrString(value)) {\n    streamValue = value.buffer;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n\n  // from https://github.com/sindresorhus/to-readable-stream/blob/main/index.js\n  return new ReadableStream<ArrayBuffer>({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    },\n  });\n}\n\n// From https://github.com/sindresorhus/is-stream/\nfunction isNodeJsReadableStream(value: PutBody): value is Readable {\n  return (\n    typeof value === 'object' &&\n    typeof (value as Readable).pipe === 'function' &&\n    (value as Readable).readable &&\n    typeof (value as Readable)._read === 'function' &&\n    // @ts-expect-error _readableState does exists on Readable\n    typeof value._readableState === 'object'\n  );\n}\n\nfunction stringToUint8Array(s: string): Uint8Array {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\n\nfunction isNodeJsBufferOrString(input: Buffer | string): input is Buffer {\n  return isBuffer(input);\n}\n","import { debug } from '../debug';\nimport type { BlobCommandOptions } from '../helpers';\nimport type { PutBody, PutBlobResult } from '../put-helpers';\nimport { completeMultipartUpload } from './complete';\nimport { createMultipartUpload } from './create';\nimport { toReadableStream } from './helpers';\nimport { uploadAllParts } from './upload';\n\n// this automatically slices the body into parts and uploads all of them as multiple parts\nexport async function uncontrolledMultipartUpload(\n  pathname: string,\n  body: PutBody,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<PutBlobResult> {\n  debug('mpu: init', 'pathname:', pathname, 'headers:', headers);\n\n  const stream = toReadableStream(body);\n\n  // Step 1: Start multipart upload\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    options,\n  );\n\n  // Step 2: Upload parts one by one\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n  });\n\n  // Step 3: Complete multipart upload\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options,\n  });\n\n  return blob;\n}\n","import type { BodyInit } from 'undici';\nimport { requestApi } from './api';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError } from './helpers';\nimport { uncontrolledMultipartUpload } from './multipart/uncontrolled';\nimport type {\n  CreatePutMethodOptions,\n  PutBody,\n  PutBlobApiResponse,\n  PutBlobResult,\n} from './put-helpers';\nimport { createPutOptions, createPutHeaders } from './put-helpers';\n\nexport interface PutCommandOptions extends CommonCreateBlobOptions {\n  /**\n   * Whether to use multipart upload. Use this when uploading large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.\n   * @defaultvalue false\n   */\n  multipart?: boolean;\n}\n\nexport function createPutMethod<TOptions extends PutCommandOptions>({\n  allowedOptions,\n  getToken,\n  extraChecks,\n}: CreatePutMethodOptions<TOptions>) {\n  return async function put<TPath extends string>(\n    pathname: TPath,\n    bodyOrOptions: TPath extends `${string}/` ? TOptions : PutBody,\n    optionsInput?: TPath extends `${string}/` ? never : TOptions,\n  ): Promise<PutBlobResult> {\n    const isFolderCreation = pathname.endsWith('/');\n\n    // prevent empty bodies for files\n    if (!bodyOrOptions && !isFolderCreation) {\n      throw new BlobError('body is required');\n    }\n\n    // runtime check for non TS users that provide all three args\n    if (bodyOrOptions && optionsInput && isFolderCreation) {\n      throw new BlobError('body is not allowed for creating empty folders');\n    }\n\n    // avoid using the options as body\n    const body = isFolderCreation ? undefined : bodyOrOptions;\n\n    const options = await createPutOptions({\n      pathname,\n      // when no body is required (for folder creations) options are the second argument\n      options: isFolderCreation ? (bodyOrOptions as TOptions) : optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    if (options.multipart === true && body) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n\n    const response = await requestApi<PutBlobApiResponse>(\n      `/${pathname}`,\n      {\n        method: 'PUT',\n        body: body as BodyInit,\n        headers,\n        // required in order to stream some body types to Cloudflare\n        // currently only supported in Node.js, we may have to feature detect this\n        duplex: 'half',\n      },\n      options,\n    );\n\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition,\n    };\n  };\n}\n","import type { CommonCreateBlobOptions } from '../helpers';\nimport type { CreatePutMethodOptions, PutBody } from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport { completeMultipartUpload } from './complete';\nimport { createMultipartUpload } from './create';\nimport type { Part } from './helpers';\nimport { uploadPart } from './upload';\n\nexport function createCreateMultipartUploaderMethod<\n  TOptions extends CommonCreateBlobOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options,\n    );\n\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n\n      async uploadPart(partNumber: number, body: PutBody) {\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options,\n        });\n\n        return {\n          etag: result.etag,\n          partNumber,\n        };\n      },\n\n      async complete(parts: Part[]) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options,\n        });\n      },\n    };\n  };\n}\n"]}