import { P as PutBody, b as PutBlobResult, c as Part, a as BlobCommandOptions, f as CommonMultipartUploadOptions, h as CommonCompleteMultipartUploadOptions } from './helpers-CYhy2oW_.cjs';
import { IncomingMessage } from 'node:http';
import 'stream';

interface ClientCommonCreateBlobOptions {
    /**
     * Whether the blob should be publicly accessible. Support for private blobs is planned.
     */
    access: 'public';
    /**
     * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.
     */
    contentType?: string;
}
interface ClientTokenOptions {
    /**
     * A client token that was generated by your server using the `generateClientToken` method.
     */
    token: string;
}
interface ClientCommonPutOptions extends ClientCommonCreateBlobOptions {
    /**
     * Whether to use multipart upload. Use this when uploading large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.
     */
    multipart?: boolean;
}
type ClientPutCommandOptions = ClientCommonPutOptions & ClientTokenOptions;
declare const put: <TPath extends string>(pathname: TPath, bodyOrOptions: TPath extends `${string}/` ? ClientPutCommandOptions : PutBody, optionsInput?: (TPath extends `${string}/` ? never : ClientPutCommandOptions) | undefined) => Promise<PutBlobResult>;
type ClientCreateMultipartUploadCommandOptions = ClientCommonCreateBlobOptions & ClientTokenOptions;
declare const createMultipartUpload: (pathname: string, optionsInput: ClientCreateMultipartUploadCommandOptions) => Promise<{
    key: string;
    uploadId: string;
}>;
declare const createMultipartUploader: (pathname: string, optionsInput: ClientCreateMultipartUploadCommandOptions) => Promise<{
    key: string;
    uploadId: string;
    uploadPart(partNumber: number, body: PutBody): Promise<{
        etag: string; /**
         * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.
         */
        partNumber: number;
    }>;
    complete(parts: Part[]): Promise<PutBlobResult>;
}>;
type ClientMultipartUploadCommandOptions = ClientCommonCreateBlobOptions & ClientTokenOptions & CommonMultipartUploadOptions;
declare const uploadPart: (pathname: string, body: PutBody, optionsInput: ClientMultipartUploadCommandOptions) => Promise<Part>;
type ClientCompleteMultipartUploadCommandOptions = ClientCommonCreateBlobOptions & ClientTokenOptions & CommonCompleteMultipartUploadOptions;
declare const completeMultipartUpload: (pathname: string, parts: Part[], optionsInput: ClientCompleteMultipartUploadCommandOptions) => Promise<PutBlobResult>;
interface CommonUploadOptions {
    /**
     * A route that implements the `handleUpload` function for generating a client token.
     */
    handleUploadUrl: string;
    /**
     * Additional data which will be sent to your `handleUpload` route.
     */
    clientPayload?: string;
}
type UploadOptions = ClientCommonPutOptions & CommonUploadOptions;
/**
 * Uploads a blob into your store from the client.
 * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads
 *
 * If you want to upload from your server instead, check out the documentation for the put operation: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob
 *
 * @param pathname - The pathname to upload the blob to. This includes the filename.
 * @param body - The contents of your blob. This has to be a supported fetch body type https://developer.mozilla.org/en-US/docs/Web/API/fetch#body.
 * @param options - Additional options.
 */
declare const upload: <TPath extends string>(pathname: TPath, bodyOrOptions: TPath extends `${string}/` ? UploadOptions : PutBody, optionsInput?: (TPath extends `${string}/` ? never : UploadOptions) | undefined) => Promise<PutBlobResult>;
type DecodedClientTokenPayload = Omit<GenerateClientTokenOptions, 'token'> & {
    validUntil: number;
};
declare function getPayloadFromClientToken(clientToken: string): DecodedClientTokenPayload;
declare const EventTypes: {
    readonly generateClientToken: "blob.generate-client-token";
    readonly uploadCompleted: "blob.upload-completed";
};
interface GenerateClientTokenEvent {
    type: (typeof EventTypes)['generateClientToken'];
    payload: {
        pathname: string;
        callbackUrl: string;
        multipart: boolean;
        clientPayload: string | null;
    };
}
interface UploadCompletedEvent {
    type: (typeof EventTypes)['uploadCompleted'];
    payload: {
        blob: PutBlobResult;
        tokenPayload?: string | null;
    };
}
type HandleUploadBody = GenerateClientTokenEvent | UploadCompletedEvent;
type RequestType = IncomingMessage | Request;
interface HandleUploadOptions {
    body: HandleUploadBody;
    onBeforeGenerateToken: (pathname: string, clientPayload: string | null, multipart: boolean) => Promise<Pick<GenerateClientTokenOptions, 'allowedContentTypes' | 'maximumSizeInBytes' | 'validUntil' | 'addRandomSuffix' | 'cacheControlMaxAge'> & {
        tokenPayload?: string | null;
    }>;
    onUploadCompleted: (body: UploadCompletedEvent['payload']) => Promise<void>;
    token?: string;
    request: RequestType;
}
declare function handleUpload({ token, request, body, onBeforeGenerateToken, onUploadCompleted, }: HandleUploadOptions): Promise<{
    type: GenerateClientTokenEvent['type'];
    clientToken: string;
} | {
    type: UploadCompletedEvent['type'];
    response: 'ok';
}>;
declare function generateClientTokenFromReadWriteToken({ token, ...argsWithoutToken }: GenerateClientTokenOptions): Promise<string>;
interface GenerateClientTokenOptions extends BlobCommandOptions {
    pathname: string;
    onUploadCompleted?: {
        callbackUrl: string;
        tokenPayload?: string | null;
    };
    maximumSizeInBytes?: number;
    allowedContentTypes?: string[];
    validUntil?: number;
    addRandomSuffix?: boolean;
    cacheControlMaxAge?: number;
}

export { type ClientCommonCreateBlobOptions, type ClientCreateMultipartUploadCommandOptions, type ClientPutCommandOptions, type ClientTokenOptions, type CommonUploadOptions, type DecodedClientTokenPayload, type GenerateClientTokenOptions, type HandleUploadBody, type HandleUploadOptions, type UploadOptions, completeMultipartUpload, createMultipartUpload, createMultipartUploader, generateClientTokenFromReadWriteToken, getPayloadFromClientToken, handleUpload, put, upload, uploadPart };
